## 動態規劃演算法(Dynamic Programming)

1. 試著在有條件限制的情況下找出最佳解答時，動態規劃演算法可以發揮最大優勢。以背包問題為例，必須在背包容量的限制下，找出最高價值的物品組合。

2. 動態規劃演算法適合用在可以將問題分割成獨立的子問題，不適合用在具有相依性(depend)的子問題。

3. 每個動態規劃解答都一定會用到表格。

4. 動態規劃的目的是將每個格子的值最大化。以背包問題為例，每個格子的值就是物品的價值。

5. 每個格子代表一個子問題，所以如何將原本的問題分割成小問題就是關鍵。

6. 動態規劃的解答沒有一定的計算公式。

---

### 最長共用子序列(Longest common subsequence)
比較兩個單字最長共用子序列

```js
if (wordA[i] === wordB[j]) {
  // 若字母一樣，將左上方格子值 + 1
  cell[i][j] = cell[i - 1][j - 1] + 1;
} else {
  // 若字母不同，以較大值為主
  cell[i][j] = max(cell[i - 1][j], cell[i][j - 1])
}
```
